"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
Object.defineProperty(exports, "__esModule", { value: true });
var coreutils_1 = require("@phosphor/coreutils");
/* tslint:disable */
/**
 * The default state database token.
 */
exports.IStateDB = new coreutils_1.Token('jupyter.services.statedb');
/**
 * The default concrete implementation of a state database.
 */
var StateDB = (function () {
    /**
     * Create a new state database.
     *
     * @param options - The instantiation options for a state database.
     */
    function StateDB(options) {
        /**
         * The maximum allowed length of the data after it has been serialized.
         */
        this.maxLength = 2000;
        this.namespace = options.namespace;
    }
    /**
     * Clear the entire database.
     */
    StateDB.prototype.clear = function () {
        var prefix = this.namespace + ":";
        var i = window.localStorage.length;
        while (i) {
            var key = window.localStorage.key(--i);
            if (key && key.indexOf(prefix) === 0) {
                window.localStorage.removeItem(key);
            }
        }
        return Promise.resolve(void 0);
    };
    /**
     * Retrieve a saved bundle from the database.
     *
     * @param id - The identifier used to retrieve a data bundle.
     *
     * @returns A promise that bears a data payload if available.
     *
     * #### Notes
     * The `id` values of stored items in the state database are formatted:
     * `'namespace:identifier'`, which is the same convention that command
     * identifiers in JupyterLab use as well. While this is not a technical
     * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
     * using the `fetchNamespace()` method.
     *
     * The promise returned by this method may be rejected if an error occurs in
     * retrieving the data. Non-existence of an `id` will succeed with `null`.
     */
    StateDB.prototype.fetch = function (id) {
        var key = this.namespace + ":" + id;
        var value = window.localStorage.getItem(key);
        if (!value) {
            return Promise.resolve(undefined);
        }
        try {
            return Promise.resolve(JSON.parse(value));
        }
        catch (error) {
            return Promise.reject(error);
        }
    };
    /**
     * Retrieve all the saved bundles for a namespace.
     *
     * @param namespace - The namespace to retrieve.
     *
     * @returns A promise that bears a collection data payloads for a namespace.
     *
     * #### Notes
     * Namespaces are entirely conventional entities. The `id` values of stored
     * items in the state database are formatted: `'namespace:identifier'`, which
     * is the same convention that command identifiers in JupyterLab use as well.
     *
     * If there are any errors in retrieving the data, they will be logged to the
     * console in order to optimistically return any extant data without failing.
     * This promise will always succeed.
     */
    StateDB.prototype.fetchNamespace = function (namespace) {
        var prefix = this.namespace + ":" + namespace + ":";
        var regex = new RegExp("^" + this.namespace + ":");
        var items = [];
        var i = window.localStorage.length;
        while (i) {
            var key = window.localStorage.key(--i);
            if (key && key.indexOf(prefix) === 0) {
                var value = window.localStorage.getItem(key);
                try {
                    items.push({
                        id: key.replace(regex, ''),
                        value: value ? JSON.parse(value) : undefined
                    });
                }
                catch (error) {
                    console.warn(error);
                    window.localStorage.removeItem(key);
                }
            }
        }
        return Promise.resolve(items);
    };
    /**
     * Remove a value from the database.
     *
     * @param id - The identifier for the data being removed.
     *
     * @returns A promise that is rejected if remove fails and succeeds otherwise.
     */
    StateDB.prototype.remove = function (id) {
        window.localStorage.removeItem(this.namespace + ":" + id);
        return Promise.resolve(void 0);
    };
    /**
     * Save a value in the database.
     *
     * @param id - The identifier for the data being saved.
     *
     * @param value - The data being saved.
     *
     * @returns A promise that is rejected if saving fails and succeeds otherwise.
     *
     * #### Notes
     * The `id` values of stored items in the state database are formatted:
     * `'namespace:identifier'`, which is the same convention that command
     * identifiers in JupyterLab use as well. While this is not a technical
     * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
     * using the `fetchNamespace()` method.
     */
    StateDB.prototype.save = function (id, value) {
        try {
            var key = this.namespace + ":" + id;
            var serialized = JSON.stringify(value);
            var length_1 = serialized.length;
            var max = this.maxLength;
            if (length_1 > max) {
                throw new Error("Data length (" + length_1 + ") exceeds maximum (" + max + ")");
            }
            window.localStorage.setItem(key, serialized);
            return Promise.resolve(void 0);
        }
        catch (error) {
            return Promise.reject(error);
        }
    };
    return StateDB;
}());
exports.StateDB = StateDB;
