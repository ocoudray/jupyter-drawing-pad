"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var coreutils_1 = require("@jupyterlab/coreutils");
var algorithm_1 = require("@phosphor/algorithm");
var signaling_1 = require("@phosphor/signaling");
var __1 = require("..");
var terminal_1 = require("./terminal");
/**
 * The url for the terminal service.
 */
var TERMINAL_SERVICE_URL = 'api/terminals';
/**
 * An implementation of a terminal interface.
 */
var DefaultTerminalSession = (function () {
    /**
     * Construct a new terminal session.
     */
    function DefaultTerminalSession(name, options) {
        if (options === void 0) { options = {}; }
        this._ws = null;
        this._isDisposed = false;
        this._isReady = false;
        this._messageReceived = new signaling_1.Signal(this);
        this._name = name;
        this.serverSettings = options.serverSettings || __1.ServerConnection.makeSettings();
        this._readyPromise = this._initializeSocket();
        this.terminated = new signaling_1.Signal(this);
    }
    Object.defineProperty(DefaultTerminalSession.prototype, "messageReceived", {
        /**
         * A signal emitted when a message is received from the server.
         */
        get: function () {
            return this._messageReceived;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "name", {
        /**
         * Get the name of the terminal session.
         */
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "model", {
        /**
         * Get the model for the terminal session.
         */
        get: function () {
            return { name: this._name };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "isReady", {
        /**
         * Test whether the session is ready.
         */
        get: function () {
            return this._isReady;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "ready", {
        /**
         * A promise that fulfills when the session is ready.
         */
        get: function () {
            return this._readyPromise;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "isDisposed", {
        /**
         * Test whether the session is disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the session.
     */
    DefaultTerminalSession.prototype.dispose = function () {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        if (this._ws) {
            this._ws.close();
            this._ws = null;
        }
        delete Private.running[this._url];
        signaling_1.Signal.clearData(this);
    };
    /**
     * Send a message to the terminal session.
     */
    DefaultTerminalSession.prototype.send = function (message) {
        var _this = this;
        if (this._isDisposed || !message.content) {
            return;
        }
        var msg = [message.type];
        msg.push.apply(msg, message.content);
        var value = JSON.stringify(msg);
        if (this._isReady && this._ws) {
            this._ws.send(value);
            return;
        }
        this.ready.then(function () {
            if (_this._ws) {
                _this._ws.send(value);
            }
        });
    };
    /**
     * Reconnect to the terminal.
     *
     * @returns A promise that resolves when the terminal has reconnected.
     */
    DefaultTerminalSession.prototype.reconnect = function () {
        this._readyPromise = this._initializeSocket();
        return this._readyPromise;
    };
    /**
     * Shut down the terminal session.
     */
    DefaultTerminalSession.prototype.shutdown = function () {
        return DefaultTerminalSession.shutdown(this.name, this.serverSettings);
    };
    /**
     * Connect to the websocket.
     */
    DefaultTerminalSession.prototype._initializeSocket = function () {
        var _this = this;
        var name = this._name;
        if (this._ws) {
            this._ws.close();
        }
        this._isReady = false;
        var settings = this.serverSettings;
        this._url = Private.getTermUrl(settings.baseUrl, this._name);
        Private.running[this._url] = this;
        var wsUrl = coreutils_1.URLExt.join(settings.wsUrl, "terminals/websocket/" + name);
        var token = this.serverSettings.token;
        if (token) {
            wsUrl = wsUrl + ("?token=" + token);
        }
        this._ws = settings.wsFactory(wsUrl);
        this._ws.onmessage = function (event) {
            if (_this._isDisposed) {
                return;
            }
            var data = JSON.parse(event.data);
            _this._messageReceived.emit({
                type: data[0],
                content: data.slice(1)
            });
        };
        return new Promise(function (resolve, reject) {
            if (!_this._ws) {
                return;
            }
            _this._ws.onopen = function (event) {
                if (_this._isDisposed) {
                    return;
                }
                _this._isReady = true;
                resolve(void 0);
            };
            _this._ws.onerror = function (event) {
                if (_this._isDisposed) {
                    return;
                }
                reject(event);
            };
        });
    };
    return DefaultTerminalSession;
}());
exports.DefaultTerminalSession = DefaultTerminalSession;
/**
 * The static namespace for `DefaultTerminalSession`.
 */
(function (DefaultTerminalSession) {
    /**
     * Whether the terminal service is available.
     */
    function isAvailable() {
        var available = String(coreutils_1.PageConfig.getOption('terminalsAvailable'));
        return available.toLowerCase() === 'true';
    }
    DefaultTerminalSession.isAvailable = isAvailable;
    /**
     * Start a new terminal session.
     *
     * @param options - The session options to use.
     *
     * @returns A promise that resolves with the session instance.
     */
    function startNew(options) {
        if (options === void 0) { options = {}; }
        if (!terminal_1.TerminalSession.isAvailable()) {
            throw Private.unavailableMsg;
        }
        var serverSettings = options.serverSettings || __1.ServerConnection.makeSettings();
        var request = {
            url: Private.getServiceUrl(serverSettings.baseUrl),
            method: 'POST'
        };
        return __1.ServerConnection.makeRequest(request, serverSettings).then(function (response) {
            if (response.xhr.status !== 200) {
                throw __1.ServerConnection.makeError(response);
            }
            var name = response.data.name;
            return new DefaultTerminalSession(name, __assign({}, options, { serverSettings: serverSettings }));
        });
    }
    DefaultTerminalSession.startNew = startNew;
    /*
     * Connect to a running session.
     *
     * @param name - The name of the target session.
     *
     * @param options - The session options to use.
     *
     * @returns A promise that resolves with the new session instance.
     *
     * #### Notes
     * If the session was already started via `startNew`, the existing
     * session object is used as the fulfillment value.
     *
     * Otherwise, if `options` are given, we resolve the promise after
     * confirming that the session exists on the server.
     *
     * If the session does not exist on the server, the promise is rejected.
     */
    function connectTo(name, options) {
        if (options === void 0) { options = {}; }
        if (!terminal_1.TerminalSession.isAvailable()) {
            return Promise.reject(Private.unavailableMsg);
        }
        var serverSettings = options.serverSettings || __1.ServerConnection.makeSettings();
        var url = Private.getTermUrl(serverSettings.baseUrl, name);
        if (url in Private.running) {
            return Promise.resolve(Private.running[url]);
        }
        return listRunning(serverSettings).then(function (models) {
            var index = algorithm_1.ArrayExt.findFirstIndex(models, function (model) {
                return model.name === name;
            });
            if (index !== -1) {
                var session = new DefaultTerminalSession(name, __assign({}, options, { serverSettings: serverSettings }));
                return Promise.resolve(session);
            }
            return Promise.reject('Could not find session');
        });
    }
    DefaultTerminalSession.connectTo = connectTo;
    /**
     * List the running terminal sessions.
     *
     * @param settings - The server settings to use.
     *
     * @returns A promise that resolves with the list of running session models.
     */
    function listRunning(settings) {
        if (!terminal_1.TerminalSession.isAvailable()) {
            return Promise.reject(Private.unavailableMsg);
        }
        settings = settings || __1.ServerConnection.makeSettings();
        var url = Private.getServiceUrl(settings.baseUrl);
        var request = {
            url: url,
            method: 'GET'
        };
        return __1.ServerConnection.makeRequest(request, settings).then(function (response) {
            if (response.xhr.status !== 200) {
                throw __1.ServerConnection.makeError(response);
            }
            var data = response.data;
            if (!Array.isArray(data)) {
                throw __1.ServerConnection.makeError(response, 'Invalid terminal data');
            }
            // Update the local data store.
            var urls = algorithm_1.toArray(algorithm_1.map(data, function (item) {
                return coreutils_1.URLExt.join(url, item.name);
            }));
            algorithm_1.each(Object.keys(Private.running), function (runningUrl) {
                if (urls.indexOf(runningUrl) === -1) {
                    var session = Private.running[runningUrl];
                    session.terminated.emit(void 0);
                    session.dispose();
                }
            });
            return data;
        });
    }
    DefaultTerminalSession.listRunning = listRunning;
    /**
     * Shut down a terminal session by name.
     *
     * @param name - The name of the target session.
     *
     * @param settings - The server settings to use.
     *
     * @returns A promise that resolves when the session is shut down.
     */
    function shutdown(name, settings) {
        if (!terminal_1.TerminalSession.isAvailable()) {
            return Promise.reject(Private.unavailableMsg);
        }
        settings = settings || __1.ServerConnection.makeSettings();
        var url = Private.getTermUrl(settings.baseUrl, name);
        var request = {
            url: url,
            method: 'DELETE'
        };
        return __1.ServerConnection.makeRequest(request, settings).then(function (response) {
            if (response.xhr.status !== 204) {
                throw __1.ServerConnection.makeError(response);
            }
            Private.killTerminal(url);
        }).catch(function (err) {
            if (err.xhr.status === 404) {
                var response = JSON.parse(err.xhr.responseText);
                console.warn(response['message']);
                Private.killTerminal(url);
                return;
            }
            return Promise.reject(err);
        });
    }
    DefaultTerminalSession.shutdown = shutdown;
})(DefaultTerminalSession = exports.DefaultTerminalSession || (exports.DefaultTerminalSession = {}));
exports.DefaultTerminalSession = DefaultTerminalSession;
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * A mapping of running terminals by url.
     */
    Private.running = Object.create(null);
    /**
     * A promise returned for when terminals are unavailable.
     */
    Private.unavailableMsg = 'Terminals Unavailable';
    /**
     * Get the url for a terminal.
     */
    function getTermUrl(baseUrl, name) {
        return coreutils_1.URLExt.join(baseUrl, TERMINAL_SERVICE_URL, name);
    }
    Private.getTermUrl = getTermUrl;
    /**
     * Get the base url.
     */
    function getServiceUrl(baseUrl) {
        return coreutils_1.URLExt.join(baseUrl, TERMINAL_SERVICE_URL);
    }
    Private.getServiceUrl = getServiceUrl;
    /**
     * Kill a terminal by url.
     */
    function killTerminal(url) {
        // Update the local data store.
        if (Private.running[url]) {
            var session = Private.running[url];
            session.terminated.emit(void 0);
            session.dispose();
        }
    }
    Private.killTerminal = killTerminal;
})(Private || (Private = {}));
