"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
Object.defineProperty(exports, "__esModule", { value: true });
var coreutils_1 = require("@jupyterlab/coreutils");
var algorithm_1 = require("@phosphor/algorithm");
var signaling_1 = require("@phosphor/signaling");
var kernel_1 = require("../kernel");
var __1 = require("..");
var validate = require("./validate");
/**
 * The url for the session service.
 */
var SESSION_SERVICE_URL = 'api/sessions';
/**
 * Session object for accessing the session REST api. The session
 * should be used to start kernels and then shut them down -- for
 * all other operations, the kernel object should be used.
 */
var DefaultSession = (function () {
    /**
     * Construct a new session.
     */
    function DefaultSession(options, id, kernel) {
        this._id = '';
        this._path = '';
        this._name = '';
        this._type = '';
        this._uuid = '';
        this._isDisposed = false;
        this._updating = false;
        this._kernelChanged = new signaling_1.Signal(this);
        this._statusChanged = new signaling_1.Signal(this);
        this._iopubMessage = new signaling_1.Signal(this);
        this._unhandledMessage = new signaling_1.Signal(this);
        this._propertyChanged = new signaling_1.Signal(this);
        this._id = id;
        this._path = options.path;
        this._type = options.type || 'file';
        this._name = options.name || '';
        this.serverSettings = options.serverSettings || __1.ServerConnection.makeSettings();
        this._uuid = coreutils_1.uuid();
        Private.addRunning(this);
        this.setupKernel(kernel);
        this.terminated = new signaling_1.Signal(this);
    }
    Object.defineProperty(DefaultSession.prototype, "kernelChanged", {
        /**
         * A signal emitted when the kernel changes.
         */
        get: function () {
            return this._kernelChanged;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultSession.prototype, "statusChanged", {
        /**
         * A signal emitted when the kernel status changes.
         */
        get: function () {
            return this._statusChanged;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultSession.prototype, "iopubMessage", {
        /**
         * A signal emitted for a kernel messages.
         */
        get: function () {
            return this._iopubMessage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultSession.prototype, "unhandledMessage", {
        /**
         * A signal emitted for an unhandled kernel message.
         */
        get: function () {
            return this._unhandledMessage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultSession.prototype, "propertyChanged", {
        /**
         * A signal emitted when a session property changes.
         */
        get: function () {
            return this._propertyChanged;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultSession.prototype, "id", {
        /**
         * Get the session id.
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultSession.prototype, "kernel", {
        /**
         * Get the session kernel object.
         *
         * #### Notes
         * This is a read-only property, and can be altered by [changeKernel].
         * Use the [statusChanged] and [unhandledMessage] signals on the session
         * instead of the ones on the kernel.
         */
        get: function () {
            return this._kernel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultSession.prototype, "path", {
        /**
         * Get the session path.
         */
        get: function () {
            return this._path;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultSession.prototype, "type", {
        /**
         * Get the session type.
         */
        get: function () {
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultSession.prototype, "name", {
        /**
         * Get the session name.
         */
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultSession.prototype, "model", {
        /**
         * Get the model associated with the session.
         */
        get: function () {
            return {
                id: this.id,
                kernel: this.kernel.model,
                path: this._path,
                type: this._type,
                name: this._name
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultSession.prototype, "status", {
        /**
         * The current status of the session.
         *
         * #### Notes
         * This is a delegate to the kernel status.
         */
        get: function () {
            return this._kernel ? this._kernel.status : 'dead';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultSession.prototype, "isDisposed", {
        /**
         * Test whether the session has been disposed.
         */
        get: function () {
            return this._isDisposed === true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clone the current session with a new clientId.
     */
    DefaultSession.prototype.clone = function () {
        var _this = this;
        return kernel_1.Kernel.connectTo(this.kernel.id, this.serverSettings).then(function (kernel) {
            return new DefaultSession({
                path: _this._path,
                serverSettings: _this.serverSettings
            }, _this._id, kernel);
        });
    };
    /**
     * Update the session based on a session model from the server.
     */
    DefaultSession.prototype.update = function (model) {
        var _this = this;
        // Avoid a race condition if we are waiting for a REST call return.
        if (this._updating) {
            return Promise.resolve(void 0);
        }
        var oldModel = this.model;
        this._path = model.path;
        this._name = model.name;
        this._type = model.type;
        if (this._kernel.isDisposed || model.kernel.id !== this._kernel.id) {
            return kernel_1.Kernel.connectTo(model.kernel.id, this.serverSettings).then(function (kernel) {
                _this.setupKernel(kernel);
                _this._kernelChanged.emit(kernel);
                _this._handleModelChange(oldModel);
            });
        }
        this._handleModelChange(oldModel);
        return Promise.resolve(void 0);
    };
    /**
     * Dispose of the resources held by the session.
     */
    DefaultSession.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        this._kernel.dispose();
        Private.removeRunning(this);
        signaling_1.Signal.clearData(this);
    };
    /**
     * Change the session path.
     *
     * @param path - The new session path.
     *
     * @returns A promise that resolves when the session has renamed.
     *
     * #### Notes
     * This uses the Jupyter REST API, and the response is validated.
     * The promise is fulfilled on a valid response and rejected otherwise.
     */
    DefaultSession.prototype.setPath = function (path) {
        if (this.isDisposed) {
            return Promise.reject(new Error('Session is disposed'));
        }
        var data = JSON.stringify({ path: path });
        return this._patch(data).then(function () { return void 0; });
    };
    /**
     * Change the session name.
     */
    DefaultSession.prototype.setName = function (name) {
        if (this.isDisposed) {
            return Promise.reject(new Error('Session is disposed'));
        }
        var data = JSON.stringify({ name: name });
        return this._patch(data).then(function () { return void 0; });
    };
    /**
     * Change the session type.
     */
    DefaultSession.prototype.setType = function (type) {
        if (this.isDisposed) {
            return Promise.reject(new Error('Session is disposed'));
        }
        var data = JSON.stringify({ type: type });
        return this._patch(data).then(function () { return void 0; });
    };
    /**
     * Change the kernel.
     *
     * @params options - The name or id of the new kernel.
     *
     * #### Notes
     * This shuts down the existing kernel and creates a new kernel,
     * keeping the existing session ID and session path.
     */
    DefaultSession.prototype.changeKernel = function (options) {
        var _this = this;
        if (this.isDisposed) {
            return Promise.reject(new Error('Session is disposed'));
        }
        var data = JSON.stringify({ kernel: options });
        if (this._kernel) {
            return this._kernel.ready.then(function () {
                _this._kernel.dispose();
                return _this._patch(data);
            }).then(function () { return _this.kernel; });
        }
        return this._patch(data).then(function () { return _this.kernel; });
    };
    /**
     * Kill the kernel and shutdown the session.
     *
     * @returns - The promise fulfilled on a valid response from the server.
     *
     * #### Notes
     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/sessions), and validates the response.
     * Emits a [sessionDied] signal on success.
     */
    DefaultSession.prototype.shutdown = function () {
        if (this.isDisposed) {
            return Promise.reject(new Error('Session is disposed'));
        }
        return Private.shutdownSession(this.id, this.serverSettings);
    };
    /**
     * Handle connections to a kernel.
     */
    DefaultSession.prototype.setupKernel = function (kernel) {
        this._kernel = kernel;
        kernel.statusChanged.connect(this.onKernelStatus, this);
        kernel.unhandledMessage.connect(this.onUnhandledMessage, this);
        kernel.iopubMessage.connect(this.onIOPubMessage, this);
    };
    /**
     * Handle to changes in the Kernel status.
     */
    DefaultSession.prototype.onKernelStatus = function (sender, state) {
        this._statusChanged.emit(state);
    };
    /**
     * Handle iopub kernel messages.
     */
    DefaultSession.prototype.onIOPubMessage = function (sender, msg) {
        this._iopubMessage.emit(msg);
    };
    /**
     * Handle unhandled kernel messages.
     */
    DefaultSession.prototype.onUnhandledMessage = function (sender, msg) {
        this._unhandledMessage.emit(msg);
    };
    /**
     * Send a PATCH to the server, updating the session path or the kernel.
     */
    DefaultSession.prototype._patch = function (data) {
        var _this = this;
        this._updating = true;
        var settings = this.serverSettings;
        var request = {
            url: Private.getSessionUrl(settings.baseUrl, this._id),
            method: 'PATCH',
            data: data,
            contentType: 'application/json',
            cache: false
        };
        return __1.ServerConnection.makeRequest(request, settings).then(function (response) {
            _this._updating = false;
            if (response.xhr.status !== 200) {
                throw __1.ServerConnection.makeError(response);
            }
            var value = response.data;
            try {
                validate.validateModel(value);
            }
            catch (err) {
                throw __1.ServerConnection.makeError(response, err.message);
            }
            return Private.updateFromServer(value, settings.baseUrl);
        }, function (error) {
            _this._updating = false;
            return Private.onSessionError(error);
        });
    };
    /**
     * Handle a change to the model.
     */
    DefaultSession.prototype._handleModelChange = function (oldModel) {
        if (oldModel.name !== this._name) {
            this._propertyChanged.emit('name');
        }
        if (oldModel.type !== this._type) {
            this._propertyChanged.emit('type');
        }
        if (oldModel.path !== this._path) {
            this._propertyChanged.emit('path');
        }
    };
    return DefaultSession;
}());
exports.DefaultSession = DefaultSession;
/**
 * The namespace for `DefaultSession` statics.
 */
(function (DefaultSession) {
    /**
     * List the running sessions.
     */
    function listRunning(settings) {
        return Private.listRunning(settings);
    }
    DefaultSession.listRunning = listRunning;
    /**
     * Start a new session.
     */
    function startNew(options) {
        return Private.startNew(options);
    }
    DefaultSession.startNew = startNew;
    /**
     * Find a session by id.
     */
    function findById(id, settings) {
        return Private.findById(id, settings);
    }
    DefaultSession.findById = findById;
    /**
     * Find a session by path.
     */
    function findByPath(path, settings) {
        return Private.findByPath(path, settings);
    }
    DefaultSession.findByPath = findByPath;
    /**
     * Connect to a running session.
     */
    function connectTo(id, settings) {
        return Private.connectTo(id, settings);
    }
    DefaultSession.connectTo = connectTo;
    /**
     * Shut down a session by id.
     */
    function shutdown(id, settings) {
        return Private.shutdownSession(id, settings);
    }
    DefaultSession.shutdown = shutdown;
})(DefaultSession = exports.DefaultSession || (exports.DefaultSession = {}));
exports.DefaultSession = DefaultSession;
/**
 * A namespace for session private data.
 */
var Private;
(function (Private) {
    /**
     * The running sessions mapped by base url.
     */
    var runningSessions = new Map();
    /**
     * Add a session to the running sessions.
     */
    function addRunning(session) {
        var running = (runningSessions.get(session.serverSettings.baseUrl) || []);
        running.push(session);
        runningSessions.set(session.serverSettings.baseUrl, running);
    }
    Private.addRunning = addRunning;
    /**
     * Remove a session from the running sessions.
     */
    function removeRunning(session) {
        var running = runningSessions.get(session.serverSettings.baseUrl);
        if (running) {
            algorithm_1.ArrayExt.removeFirstOf(running, session);
        }
    }
    Private.removeRunning = removeRunning;
    /**
     * Connect to a running session.
     */
    function connectTo(id, settings) {
        settings = settings || __1.ServerConnection.makeSettings();
        var running = runningSessions.get(settings.baseUrl) || [];
        var session = algorithm_1.find(running, function (value) { return value.id === id; });
        if (session) {
            return Promise.resolve(session.clone());
        }
        return getSessionModel(id, settings).then(function (model) {
            return createSession(model, settings);
        }).catch(function () {
            var msg = "No running session with id: " + id;
            return typedThrow(msg);
        });
    }
    Private.connectTo = connectTo;
    /**
     * Create a Session object.
     *
     * @returns - A promise that resolves with a started session.
     */
    function createSession(model, settings) {
        settings = settings || __1.ServerConnection.makeSettings();
        return kernel_1.Kernel.connectTo(model.kernel.id, settings).then(function (kernel) {
            return new DefaultSession({
                path: model.path,
                type: model.type,
                name: model.name,
                serverSettings: settings
            }, model.id, kernel);
        }).catch(function (error) {
            return typedThrow('Session failed to start: ' + error.message);
        });
    }
    Private.createSession = createSession;
    /**
     * Find a session by id.
     */
    function findById(id, settings) {
        settings = settings || __1.ServerConnection.makeSettings();
        var running = runningSessions.get(settings.baseUrl) || [];
        var session = algorithm_1.find(running, function (value) { return value.id === id; });
        if (session) {
            return Promise.resolve(session.model);
        }
        return getSessionModel(id, settings).catch(function () {
            var msg = "No running session for id: " + id;
            return typedThrow(msg);
        });
    }
    Private.findById = findById;
    /**
     * Find a session by path.
     */
    function findByPath(path, settings) {
        settings = settings || __1.ServerConnection.makeSettings();
        var running = runningSessions.get(settings.baseUrl) || [];
        var session = algorithm_1.find(running, function (value) { return value.path === path; });
        if (session) {
            return Promise.resolve(session.model);
        }
        return listRunning(settings).then(function (models) {
            var model = algorithm_1.find(models, function (value) {
                return value.path === path;
            });
            if (model) {
                return model;
            }
            var msg = "No running session for path: " + path;
            return typedThrow(msg);
        });
    }
    Private.findByPath = findByPath;
    /**
     * Get a full session model from the server by session id string.
     */
    function getSessionModel(id, settings) {
        settings = settings || __1.ServerConnection.makeSettings();
        var request = {
            url: getSessionUrl(settings.baseUrl, id),
            method: 'GET',
            cache: false
        };
        return __1.ServerConnection.makeRequest(request, settings).then(function (response) {
            if (response.xhr.status !== 200) {
                throw __1.ServerConnection.makeError(response);
            }
            var data = response.data;
            try {
                validate.validateModel(data);
            }
            catch (err) {
                throw __1.ServerConnection.makeError(response, err.message || String(err));
            }
            return updateFromServer(data, settings.baseUrl);
        }, Private.onSessionError);
    }
    Private.getSessionModel = getSessionModel;
    /**
     * Get a session url.
     */
    function getSessionUrl(baseUrl, id) {
        return coreutils_1.URLExt.join(baseUrl, SESSION_SERVICE_URL, id);
    }
    Private.getSessionUrl = getSessionUrl;
    /**
     * Kill the sessions by id.
     */
    function killSessions(id, baseUrl) {
        var running = runningSessions.get(baseUrl) || [];
        algorithm_1.each(running.slice(), function (session) {
            if (session.id === id) {
                session.terminated.emit(void 0);
                session.dispose();
            }
        });
    }
    /**
     * List the running sessions.
     */
    function listRunning(settings) {
        settings = settings || __1.ServerConnection.makeSettings();
        var request = {
            url: coreutils_1.URLExt.join(settings.baseUrl, SESSION_SERVICE_URL),
            method: 'GET',
            cache: false
        };
        return __1.ServerConnection.makeRequest(request, settings).then(function (response) {
            if (response.xhr.status !== 200) {
                throw __1.ServerConnection.makeError(response);
            }
            var data = response.data;
            if (!Array.isArray(response.data)) {
                throw __1.ServerConnection.makeError(response, 'Invalid Session list');
            }
            for (var i = 0; i < data.length; i++) {
                try {
                    validate.validateModel(data[i]);
                }
                catch (err) {
                    throw __1.ServerConnection.makeError(response, err.message);
                }
            }
            return updateRunningSessions(data, settings.baseUrl);
        }, Private.onSessionError);
    }
    Private.listRunning = listRunning;
    /**
     * Handle an error on a session Ajax call.
     */
    function onSessionError(error) {
        var text = (error.message ||
            error.xhr.statusText ||
            error.xhr.responseText);
        var msg = "API request failed: " + text;
        console.error(msg);
        return Promise.reject(error);
    }
    Private.onSessionError = onSessionError;
    /**
     * Shut down a session by id.
     */
    function shutdownSession(id, settings) {
        settings = settings || __1.ServerConnection.makeSettings();
        var request = {
            url: getSessionUrl(settings.baseUrl, id),
            method: 'DELETE',
            cache: false
        };
        return __1.ServerConnection.makeRequest(request, settings).then(function (response) {
            if (response.xhr.status !== 204) {
                throw __1.ServerConnection.makeError(response);
            }
            killSessions(id, settings.baseUrl);
        }, function (err) {
            if (err.xhr.status === 404) {
                var response = JSON.parse(err.xhr.responseText);
                console.warn(response['message']);
                killSessions(id, settings.baseUrl);
                return;
            }
            if (err.xhr.status === 410) {
                err.message = 'The kernel was deleted but the session was not';
            }
            return onSessionError(err);
        });
    }
    Private.shutdownSession = shutdownSession;
    /**
     * Start a new session.
     */
    function startNew(options) {
        if (options.path === void 0) {
            return Promise.reject(new Error('Must specify a path'));
        }
        return startSession(options).then(function (model) {
            return createSession(model, options.serverSettings);
        });
    }
    Private.startNew = startNew;
    /**
     * Create a new session, or return an existing session if a session if
     * the session path already exists
     */
    function startSession(options) {
        var settings = options.serverSettings || __1.ServerConnection.makeSettings();
        var model = {
            kernel: { name: options.kernelName, id: options.kernelId },
            path: options.path,
            type: options.type || '',
            name: options.name || ''
        };
        var request = {
            url: coreutils_1.URLExt.join(settings.baseUrl, SESSION_SERVICE_URL),
            method: 'POST',
            cache: false,
            data: JSON.stringify(model),
            contentType: 'application/json'
        };
        return __1.ServerConnection.makeRequest(request, settings).then(function (response) {
            if (response.xhr.status !== 201) {
                throw __1.ServerConnection.makeError(response);
            }
            try {
                validate.validateModel(response.data);
            }
            catch (err) {
                throw __1.ServerConnection.makeError(response, err.message);
            }
            var data = response.data;
            return updateFromServer(data, settings.baseUrl);
        }, onSessionError);
    }
    Private.startSession = startSession;
    /**
     * Throw a typed error.
     */
    function typedThrow(msg) {
        throw new Error(msg);
    }
    Private.typedThrow = typedThrow;
    /**
     * Update the running sessions given an updated session Id.
     */
    function updateFromServer(model, baseUrl) {
        var promises = [];
        var running = runningSessions.get(baseUrl) || [];
        algorithm_1.each(running.slice(), function (session) {
            if (session.id === model.id) {
                promises.push(session.update(model));
            }
        });
        return Promise.all(promises).then(function () { return model; });
    }
    Private.updateFromServer = updateFromServer;
    /**
     * Update the running sessions based on new data from the server.
     */
    function updateRunningSessions(sessions, baseUrl) {
        var promises = [];
        var running = runningSessions.get(baseUrl) || [];
        algorithm_1.each(running.slice(), function (session) {
            var updated = algorithm_1.find(sessions, function (sId) {
                if (session.id === sId.id) {
                    promises.push(session.update(sId));
                    return true;
                }
                return false;
            });
            // If session is no longer running on disk, emit dead signal.
            if (!updated && session.status !== 'dead') {
                session.terminated.emit(void 0);
            }
        });
        return Promise.all(promises).then(function () { return sessions; });
    }
    Private.updateRunningSessions = updateRunningSessions;
})(Private || (Private = {}));
